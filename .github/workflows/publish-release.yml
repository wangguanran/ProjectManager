name: Publish Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:

permissions:
  contents: write
  actions: read
  packages: write

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y patchelf binutils git

      - name: Build project
        shell: bash
        run: bash build.sh

      - name: Run tests
        shell: bash
        run: bash -lc "source venv/bin/activate && pytest"

      - name: Run lint
        shell: bash
        run: bash -lc "source venv/bin/activate && make lint"

  build-binaries:
    name: build-binaries (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install system dependencies (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y patchelf binutils

      - name: Build project
        shell: bash
        run: bash build.sh

      - name: Compute artifact metadata
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          uname_s="$(uname -s 2>/dev/null || echo unknown)"
          case "$uname_s" in
            Linux) platform="linux" ;;
            Darwin) platform="macos" ;;
            MINGW*|MSYS*|CYGWIN*|Windows_NT) platform="windows" ;;
            *) platform="unknown" ;;
          esac
          arch="$(uname -m 2>/dev/null || echo unknown)"
          case "$arch" in
            x86_64|amd64) arch="x86_64" ;;
            aarch64|arm64) arch="arm64" ;;
          esac
          echo "platform=$platform" >> "$GITHUB_OUTPUT"
          echo "arch=$arch" >> "$GITHUB_OUTPUT"

      - name: Prepare release binary
        id: package
        shell: bash
        run: |
          set -euo pipefail
          if [ -f out/projman_binary_path.txt ]; then
            binary_path="$(cat out/projman_binary_path.txt)"
          else
            binary_path=""
          fi

          if [ -n "$binary_path" ] && [ -e "$binary_path" ]; then
            ext=""
            case "$binary_path" in
              *.exe) ext=".exe" ;;
              *.pkg) ext=".pkg" ;;
            esac
            out_file="out/release_upload/projman-${{ steps.meta.outputs.platform }}-${{ steps.meta.outputs.arch }}${ext}"
            mkdir -p out/release_upload
            cp -L "$binary_path" "$out_file"
            echo "upload_path=$out_file" >> "$GITHUB_OUTPUT"
          else
            echo "Warning: stable binary path unavailable, falling back to upload full out/ directory."
            find out -maxdepth 5 \( -type f -o -type l \) | sed 's#^#  - #' || true
            echo "upload_path=out" >> "$GITHUB_OUTPUT"
          fi

      - name: Upload binary artifact
        uses: actions/upload-artifact@v4
        with:
          name: projman-${{ steps.meta.outputs.platform }}-${{ steps.meta.outputs.arch }}
          if-no-files-found: error
          path: ${{ steps.package.outputs.upload_path }}

  release:
    runs-on: ubuntu-latest
    needs: [test, build-binaries]

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Create release assets
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p release
          copied=0
          while IFS= read -r file; do
            name="$(basename "$file")"
            cp "$file" "release/$name"
            sha256sum "release/$name" > "release/$name.sha256"
            copied=$((copied + 1))
          done < <(find artifacts/projman-* -type f -name 'projman-*' | sort)

          if [ "$copied" -eq 0 ]; then
            echo "No release binaries collected from artifacts/" >&2
            find artifacts -maxdepth 3 -type f | sed 's#^#  - #' >&2 || true
            exit 1
          fi

      - name: Collect release commit range
        id: commit_meta
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p release
          current_tag="${GITHUB_REF_NAME}"
          current_sha="${GITHUB_SHA}"
          previous_tag="$(git tag --sort=-v:refname | grep -Fx -v "$current_tag" | head -n1 || true)"

          if [ -n "$previous_tag" ]; then
            compare_url="https://github.com/${GITHUB_REPOSITORY}/compare/${previous_tag}...${current_tag}"
            range="${previous_tag}..${current_sha}"
          else
            compare_url=""
            range="${current_sha}"
          fi

          git log --pretty=format:'%H%x09%s' ${range} > release/commits.tsv || true
          if [ ! -s release/commits.tsv ]; then
            git log -1 --pretty=format:'%H%x09%s' "${current_sha}" > release/commits.tsv
          fi

          echo "previous_tag=${previous_tag}" >> "$GITHUB_OUTPUT"
          echo "compare_url=${compare_url}" >> "$GITHUB_OUTPUT"

      - name: Generate AI feature summary (opt-in)
        continue-on-error: true
        shell: bash
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          ENABLE_AI_RELEASE_SUMMARY: ${{ vars.ENABLE_AI_RELEASE_SUMMARY }}
        run: |
          set -euo pipefail
          python - <<'PY'
          import json
          import os
          import re
          import urllib.request
          from pathlib import Path

          def truthy(val: str) -> bool:
              return str(val or "").strip().lower() in {"1", "true", "yes", "y", "on"}

          # Explicit opt-in to avoid accidentally exfiltrating commit messages to a third-party service.
          if not truthy(os.environ.get("ENABLE_AI_RELEASE_SUMMARY", "")):
              raise SystemExit(0)

          if not os.environ.get("OPENAI_API_KEY"):
              raise SystemExit(0)

          commits_file = Path("release/commits.tsv")
          if not commits_file.exists() or commits_file.stat().st_size == 0:
              raise SystemExit(0)

          commits = []
          for line in commits_file.read_text(encoding="utf-8").splitlines():
              if "\t" not in line:
                  continue
              sha, subject = line.split("\t", 1)
              subject = subject.strip().replace("\r", " ").replace("\n", " ")
              subject = re.sub(r"[\x00-\x1f\x7f]", " ", subject)
              subject = re.sub(r"\s+", " ", subject).strip()
              # Best-effort redaction for common secret-shaped patterns.
              subject = re.sub(r"(?i)(api[_-]?key|token|secret|password)\s*[:=]\s*\S+", r"\1=***", subject)
              subject = re.sub(r"(?i)\bbearer\s+[A-Za-z0-9._-]+", "Bearer ***", subject)
              subject = subject[:120]
              if not subject:
                  continue
              commits.append(f"- {sha[:7]} {subject}")
          if not commits:
              raise SystemExit(0)

          max_commits = 20
          max_commit_chars = 3500
          selected = []
          total_chars = 0
          for item in commits:
              if len(selected) >= max_commits:
                  break
              if total_chars + len(item) + 1 > max_commit_chars:
                  break
              selected.append(item)
              total_chars += len(item) + 1

          prompt = (
              "Summarize this release in 3-5 concise bullet points. "
              "Focus on user-visible features, stability improvements, and CI/release quality upgrades. "
              "Keep it technical and professional.\n\n"
              + "\n".join(selected)
          )

          payload = {
              "model": "gpt-4.1-mini",
              "input": [
                  {
                      "role": "system",
                      "content": "You are a release manager writing concise technical release highlights.",
                  },
                  {"role": "user", "content": prompt},
              ],
              "temperature": 0.2,
              "max_output_tokens": 240,
          }
          req = urllib.request.Request(
              "https://api.openai.com/v1/responses",
              data=json.dumps(payload).encode("utf-8"),
              headers={
                  "Authorization": f"Bearer {os.environ['OPENAI_API_KEY']}",
                  "Content-Type": "application/json",
              },
          )
          with urllib.request.urlopen(req, timeout=45) as response:
              result = json.loads(response.read().decode("utf-8"))

          text = (result.get("output_text") or "").strip()
          if not text:
              texts = []
              for item in result.get("output", []):
                  for content in item.get("content", []):
                      candidate = content.get("text")
                      if isinstance(candidate, str) and candidate.strip():
                          texts.append(candidate.strip())
              text = "\n".join(texts).strip()

          if text:
              Path("release/AI_SUMMARY.md").write_text(text + "\n", encoding="utf-8")
          PY

      - name: Generate release notes
        shell: bash
        env:
          PREVIOUS_TAG: ${{ steps.commit_meta.outputs.previous_tag }}
          COMPARE_URL: ${{ steps.commit_meta.outputs.compare_url }}
        run: |
          set -euo pipefail
          python - <<'PY'
          import os
          import re
          from pathlib import Path

          repo = os.environ["GITHUB_REPOSITORY"]
          tag = os.environ["GITHUB_REF_NAME"]
          previous_tag = os.environ.get("PREVIOUS_TAG", "").strip()
          compare_url = os.environ.get("COMPARE_URL", "").strip()

          commits = []
          commits_file = Path("release/commits.tsv")
          if commits_file.exists():
              for line in commits_file.read_text(encoding="utf-8").splitlines():
                  if "\t" not in line:
                      continue
                  sha, subject = line.split("\t", 1)
                  subject = subject.strip()
                  if subject:
                      commits.append((sha, subject))

          def classify(subject: str) -> str:
              s = subject.lower()
              if re.search(r"\b(feat|feature|support|add|introduce|upgrade|implement)\b", s):
                  return "feature"
              if re.search(r"\b(fix|bug|harden|correct|stabil|ensure|repair)\b", s):
                  return "fix"
              if re.search(r"\b(ci|workflow|release|build|test|lint|qa)\b", s):
                  return "release"
              return "other"

          by_type = {"feature": [], "fix": [], "release": [], "other": []}
          for sha, subject in commits:
              by_type[classify(subject)].append((sha, subject))

          ai_summary = ""
          ai_summary_file = Path("release/AI_SUMMARY.md")
          if ai_summary_file.exists():
              ai_summary = ai_summary_file.read_text(encoding="utf-8").strip()

          lines = []
          lines.append(f"# ProjectManager Release {tag}")
          lines.append("")
          lines.append("## Overview")
          lines.append(f"- Release tag: `{tag}`")
          lines.append(f"- Commit SHA: `{os.environ['GITHUB_SHA'][:12]}`")
          if previous_tag:
              lines.append(f"- Previous tag: `{previous_tag}`")
          if compare_url:
              lines.append(f"- Compare: {compare_url}")
          lines.append("")
          lines.append("## Highlights")
          if ai_summary:
              lines.extend(ai_summary.splitlines())
          else:
              if by_type["feature"]:
                  lines.append("- Feature updates:")
                  for _, subject in by_type["feature"][:4]:
                      lines.append(f"  - {subject}")
              if by_type["fix"]:
                  lines.append("- Stability and fixes:")
                  for _, subject in by_type["fix"][:4]:
                      lines.append(f"  - {subject}")
              if by_type["release"]:
                  lines.append("- Release and CI improvements:")
                  for _, subject in by_type["release"][:4]:
                      lines.append(f"  - {subject}")
              if not (by_type["feature"] or by_type["fix"] or by_type["release"]):
                  for _, subject in commits[:6]:
                      lines.append(f"- {subject}")
          lines.append("")
          lines.append("## Key Commits")
          shown = commits[:30]
          for sha, subject in shown:
              lines.append(f"- [`{sha[:7]}`](https://github.com/{repo}/commit/{sha}) {subject}")
          if len(commits) > len(shown):
              lines.append(f"- ... and {len(commits) - len(shown)} more commits")
          lines.append("")
          lines.append("## Install")
          lines.append("")
          lines.append("### Linux/macOS")
          lines.append("```bash")
          lines.append(f"curl -fsSL https://raw.githubusercontent.com/{repo}/{tag}/get_latest_release.sh | bash")
          lines.append("projman --version")
          lines.append("```")
          lines.append("")
          lines.append("### Windows")
          lines.append("```powershell")
          lines.append(f"iwr -useb https://raw.githubusercontent.com/{repo}/{tag}/install.ps1 | iex")
          lines.append("projman --version")
          lines.append("```")
          lines.append("")
          lines.append("## Assets & Checksums")
          binaries = sorted(p for p in Path("release").glob("projman-*") if p.is_file() and p.suffix != ".sha256")
          for binary in binaries:
              sha_file = binary.with_name(binary.name + ".sha256")
              sha_value = ""
              if sha_file.exists():
                  sha_value = sha_file.read_text(encoding="utf-8").split()[0]
              if sha_value:
                  lines.append(f"- `{binary.name}` â€” `{sha_value}`")
              else:
                  lines.append(f"- `{binary.name}`")

          Path("release/RELEASE_NOTES.md").write_text("\n".join(lines).rstrip() + "\n", encoding="utf-8")
          PY

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          files: |
            release/projman-*
          body_path: release/RELEASE_NOTES.md
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  publish-pypi:
    name: publish-pypi
    runs-on: ubuntu-latest
    needs: release
    env:
      PACKAGE_NAME: multi-project-manager
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Resolve package version from release tag
        id: version
        shell: bash
        run: |
          set -euo pipefail
          tag="${GITHUB_REF_NAME}"
          if [[ "$tag" =~ ^v([0-9]+\.[0-9]+\.[0-9]+)$ ]]; then
            echo "package_version=${BASH_REMATCH[1]}" >> "$GITHUB_OUTPUT"
            echo "Resolved package version: ${BASH_REMATCH[1]}"
          else
            echo "Expected a release tag like vX.Y.Z, got '${tag}'." >&2
            exit 1
          fi

      - name: Validate pyproject version matches release tag
        shell: bash
        env:
          PACKAGE_VERSION: ${{ steps.version.outputs.package_version }}
        run: |
          set -euo pipefail
          pyproject_version="$(
            python - <<'PY'
          import tomllib
          from pathlib import Path

          data = tomllib.loads(Path("pyproject.toml").read_text(encoding="utf-8"))
          print(data["project"]["version"])
          PY
          )"
          if [ "$pyproject_version" != "$PACKAGE_VERSION" ]; then
            echo "Version mismatch: pyproject=${pyproject_version}, tag=${PACKAGE_VERSION}" >&2
            exit 1
          fi

      - name: Install build dependencies
        run: |
          python -m pip install --upgrade pip
          pip install build twine

      - name: Check PyPI token configured
        env:
          PYPI_API_TOKEN: ${{ secrets.PYPI_API_TOKEN }}
        run: |
          if [ -z "${PYPI_API_TOKEN:-}" ]; then
            echo "PYPI_API_TOKEN is not configured." >&2
            exit 1
          fi

      - name: Build package
        run: |
          python scripts/write_build_info.py
          python -m build

      - name: Check existing version on PyPI
        id: pypi_check
        shell: bash
        env:
          PACKAGE_VERSION: ${{ steps.version.outputs.package_version }}
        run: |
          set -euo pipefail
          if python - <<'PY'
          import json
          import os
          import urllib.request
          import urllib.error

          name = "multi-project-manager"
          version = os.environ["PACKAGE_VERSION"]
          url = f"https://pypi.org/pypi/{name}/json"

          try:
              with urllib.request.urlopen(url, timeout=20) as response:
                  payload = json.load(response)
          except urllib.error.HTTPError as exc:
              if exc.code == 404:
                  raise SystemExit(1)
              raise

          releases = payload.get("releases", {})
          raise SystemExit(0 if version in releases else 1)
          PY
          then
            echo "exists=true" >> "$GITHUB_OUTPUT"
            echo "PyPI already has ${PACKAGE_NAME} ${PACKAGE_VERSION}; skip upload."
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
            echo "PyPI does not have ${PACKAGE_NAME} ${PACKAGE_VERSION}; continue upload."
          fi

      - name: Publish to PyPI
        if: steps.pypi_check.outputs.exists != 'true'
        env:
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.PYPI_API_TOKEN }}
        run: |
          python -m twine upload --repository-url https://upload.pypi.org/legacy/ dist/*

  publish-docker:
    name: publish-docker
    runs-on: ubuntu-latest
    needs: release
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=raw,value=latest
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=ref,event=branch
            type=sha,prefix=sha-

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
