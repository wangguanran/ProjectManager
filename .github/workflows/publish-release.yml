name: Publish Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:

permissions:
  contents: write
  actions: read
  packages: write

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y patchelf binutils git

      - name: Build project
        shell: bash
        run: bash build.sh

      - name: Run tests
        shell: bash
        run: bash -lc "source venv/bin/activate && pytest"

      - name: Run lint
        shell: bash
        run: bash -lc "source venv/bin/activate && make lint"

  build-binaries:
    name: build-binaries (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install system dependencies (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y patchelf binutils

      - name: Build project
        shell: bash
        run: bash build.sh

      - name: Compute artifact metadata
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          uname_s="$(uname -s 2>/dev/null || echo unknown)"
          case "$uname_s" in
            Linux) platform="linux" ;;
            Darwin) platform="macos" ;;
            MINGW*|MSYS*|CYGWIN*|Windows_NT) platform="windows" ;;
            *) platform="unknown" ;;
          esac
          arch="$(uname -m 2>/dev/null || echo unknown)"
          case "$arch" in
            x86_64|amd64) arch="x86_64" ;;
            aarch64|arm64) arch="arm64" ;;
          esac
          echo "platform=$platform" >> "$GITHUB_OUTPUT"
          echo "arch=$arch" >> "$GITHUB_OUTPUT"

      - name: Upload binary artifact
        uses: actions/upload-artifact@v4
        with:
          name: projman-${{ steps.meta.outputs.platform }}-${{ steps.meta.outputs.arch }}
          if-no-files-found: error
          path: out

  release:
    runs-on: ubuntu-latest
    needs: [test, build-binaries]
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts
    
    - name: Create release assets
      shell: bash
      run: |
        set -euo pipefail
        python - <<'PY'
        from __future__ import annotations

        import hashlib
        from pathlib import Path
        import shutil
        import sys

        artifacts_root = Path("artifacts")
        release_root = Path("release")
        release_root.mkdir(parents=True, exist_ok=True)

        def iter_candidates(root: Path):
            allowed_names = {"projman", "projman.exe", "projman.pkg"}
            patterns = [
                "out/release/projman*",
                "out/binary/projman*",
                "out/binary/*/projman*",
                "projman*",
            ]

            seen: set[Path] = set()

            manifest = root / "out" / "projman_binary_path.txt"
            if manifest.exists():
                rel = Path(manifest.read_text(encoding="utf-8").strip())
                manifest_target = root / rel
                if manifest_target.exists() or manifest_target.is_symlink():
                    seen.add(manifest_target)
                    yield manifest_target

            for pattern in patterns:
                for matched in sorted(root.glob(pattern)):
                    if matched.name not in allowed_names:
                        continue
                    if matched in seen:
                        continue
                    seen.add(matched)
                    yield matched

        failures: list[str] = []
        copied = 0

        for artifact_dir in sorted(artifacts_root.glob("projman-*")):
            if not artifact_dir.is_dir():
                continue

            selected: Path | None = None
            for candidate in iter_candidates(artifact_dir):
                resolved = candidate
                if candidate.is_symlink():
                    try:
                        resolved = candidate.resolve(strict=True)
                    except FileNotFoundError:
                        continue
                if resolved.is_file():
                    selected = resolved
                    break

            if selected is None:
                failures.append(f"No binary found under {artifact_dir}")
                continue

            ext = Path(selected.name).suffix if Path(selected.name).suffix in {".exe", ".pkg"} else ""
            dest = release_root / f"{artifact_dir.name}{ext}"
            shutil.copy2(selected, dest)

            digest = hashlib.sha256(dest.read_bytes()).hexdigest()
            (release_root / f"{artifact_dir.name}{ext}.sha256").write_text(
                f"{digest}  {dest.name}\n",
                encoding="utf-8",
            )
            copied += 1

        if failures:
            for message in failures:
                print(message, file=sys.stderr)
            sys.exit(1)

        if copied == 0:
            print("No release binaries collected", file=sys.stderr)
            sys.exit(1)
        PY

        # Create release notes
        cat > release/RELEASE_NOTES.md << EOF
        # ProjectManager (projman) Release

        ## Install (Linux/macOS)

        \`\`\`bash
        curl -fsSL https://raw.githubusercontent.com/${{ github.repository }}/${{ github.ref_name }}/get_latest_release.sh | bash
        projman --version
        \`\`\`

        ## Install (Windows)

        \`\`\`powershell
        iwr -useb https://raw.githubusercontent.com/${{ github.repository }}/${{ github.ref_name }}/install.ps1 | iex
        projman --version
        \`\`\`

        ## Assets

        - projman-linux-<arch>
        - projman-macos-<arch>
        - projman-windows-<arch>.exe

        ## Checksum
        Verify the download with the provided SHA256 checksum.
        EOF
    
    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        files: |
          release/projman-*
        body_path: release/RELEASE_NOTES.md
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} 

  publish-pypi:
    name: publish-pypi
    runs-on: ubuntu-latest
    needs: release
    env:
      PACKAGE_NAME: multi-project-manager
      PACKAGE_VERSION: "0.0.12"
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install build dependencies
        run: |
          python -m pip install --upgrade pip
          pip install build twine

      - name: Check PyPI token configured
        env:
          PYPI_API_TOKEN: ${{ secrets.PYPI_API_TOKEN }}
        run: |
          if [ -z "${PYPI_API_TOKEN:-}" ]; then
            echo "PYPI_API_TOKEN is not configured." >&2
            exit 1
          fi

      - name: Build package
        run: |
          python scripts/write_build_info.py
          python -m build

      - name: Check existing version on PyPI
        id: pypi_check
        shell: bash
        run: |
          set -euo pipefail
          if python - <<'PY'
          import json
          import urllib.request
          import urllib.error

          name = "multi-project-manager"
          version = "0.0.12"
          url = f"https://pypi.org/pypi/{name}/json"

          try:
              with urllib.request.urlopen(url, timeout=20) as response:
                  payload = json.load(response)
          except urllib.error.HTTPError as exc:
              if exc.code == 404:
                  raise SystemExit(1)
              raise

          releases = payload.get("releases", {})
          raise SystemExit(0 if version in releases else 1)
          PY
          then
            echo "exists=true" >> "$GITHUB_OUTPUT"
            echo "PyPI already has ${PACKAGE_NAME} ${PACKAGE_VERSION}; skip upload."
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
            echo "PyPI does not have ${PACKAGE_NAME} ${PACKAGE_VERSION}; continue upload."
          fi

      - name: Publish to PyPI
        if: steps.pypi_check.outputs.exists != 'true'
        env:
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.PYPI_API_TOKEN }}
        run: |
          python -m twine upload --repository-url https://upload.pypi.org/legacy/ dist/*

  publish-docker:
    name: publish-docker
    runs-on: ubuntu-latest
    needs: release
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=raw,value=latest
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=ref,event=branch
            type=sha,prefix=sha-

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
